  Quick_doc
* Scalar
    상수, 값을 다 object로 취급한다.
    매개변수가 하나 일 때, 괄호와 .을 생략 할 수 있다.

* var vs. val
    - var: 변수
        한번에 선언하면서 대입가능
        var a,b,c = 5
        ==> a==5 | b == 5 | c == 5
    - val: 상수

*출력
    println
        - println("스트링" + x +"문자열"+y)
        - 문자열 앞에 s를 쓰면 $를 쓰고 변수이름을 바로 쓸 수 있습니다.
            println(s" $x 문자열이랑 한번에 작성하기 $y")
        - 수식을 입력하고 싶으면 ${ }사이에 식을 넣으면 됩니다.
            println(s"$x + $y = ${ x + y }")
    printf
        - java.lang.*은 자동으로 import됩니다.
        - java.lang.Math도 포함입니다.
            printf("Pi is %f",Math.PI)

* Range, List
    Range
        - to를 이용하면 1부터 10을 포함하는 Range생성
            val range1 = 1 to 10
        - until을 이용하면 마지막 숫자를 포함하지 않는 Range를 생성
            val range2 = 1 until 10
        - by를 이용하면 숫자를 건너 띄는 Range를 생성
            val range3 = 1 until 10 by 3
    List
        - range값 .toList통해서 확인 가능
        - toList를 통해 List로 변환
        - .filter(조건) : 조건에 맞는것만 모으기
        - .map(조건) : 각 아이템의 값을 변경하기

* method about numbers
    val num = -5
    num.abs // 5
    num.max(7) // num과 7사이 max 값
    num.min(7) // num과 7사이 min 값

* 문자열
    .reverse // 뒤집기
    .capitalize // 첫글자 대문자
    "문자열" * N // 문자열 N번 반복
    .toInt // 정수로 변환

* method
    - 리턴값이 있는 메소드를 정의하는 경우 method 정의하는 블록 {  }전에 =을 적어야한다.
        def add(x:Int, y:Int):Int = {
            return x + y        
        }
    - 리턴 키워드는 옵션 => 적지 않으면 리턴 타입은 리턴값에 의해 결정
        def addWithoutReturn(x:Int, y:Int) = { 
            x + y
        }
    - 메소드 내용이 1줄일 경우 중괄호 생략 가능
        def addWithoutBlock(x:Int, y:Int) = x + y

* anonymous function
    object LearnScala {
    
        // 매개변수로 받은 익명함수에 1과 2를 넣어서 실행하는 메소드
        def doWithOneAndTwo(f: (Int, Int) => Int) = {  
            f(1, 2) //return은 생략되었지만, f(1, 2)의 결과가 return
        }
    
        def main(args: Array[String]): Unit = {
            // ① 명시적으로 타입을 선언하는 익명함수
            val call1 = doWithOneAndTwo((x: Int, y: Int) => x + y)
        
            // ② 코드4번째 줄에서 익명함수의 매개변수 타입(Int, Int)을 이미 정했기 때문에 생략
            val call2 = doWithOneAndTwo((x, y) => x + y)  
        
            // ③ 이렇게 요약할 수도 있음
            val call3 = doWithOneAndTwo(_ + _) // 매개변수의 순서대로 _에 대입됨
        
            println(call1, call2, call3) // (3,3,3)
        }  
    }

* tuple
    val t1 = new Tuple3(1, "hello", true) // Tuple1 ~ Tuple22까지 존재
    val t2 = (1, "hello", true)

    - tuple값 접금
        var numbers = (1,2,3,4) 
        val sum = numbers._1 + numbers._2 + numbers._3 + numbers._4
    
    -값 반환
        ~ 여러개를 한번에 리턴 할 수 있다.
        
            object LearnScala {
                def swap(x:String, y:String) = (y, x)  
        
                def main(args: Array[String]): Unit = {
                    val (a,b) = swap("hello","world")
                    println(a, b)
                }
            }
        ~ 한번에 여러개의 변수에 값을 넣을 수 있다.
            var (x, y, z, c, python, java) = (1, 2, 3, true, false, "no!")

* while, for
    - ++ , -- 제공 안함
    - while문
        var i, sum = 0  
        while ( i < 10) {  
            sum += i  
            i+=1 
        }
        
    - for문
        for ( i <- 0 until 10) {  
            sum += i  
        }  
        
    - 가장 스칼라스럽게 합을 구하는 방법
        sum = (0 until 10).sum  
    
    -중첩 for문
        여러개의 range를 세미콜론으로 구분해서 적어주는것.
        for( a <- 1 to 3; b <- 10 to 12){
            println(a,b)
        }

* if
    - Java, C와 거의 같다
        ~ 한줄은 {} 생략 가능
        ~ 여러줄은 {} 필요
        ~ 삼항연산자
            val likeEggs = false
            val breakfast = if (likeEggs) "계란후라이" else "사과"
            // 아침으로 사과를 먹어요

* Array
    - int[] == Array[Int]
    - mutable하다 => 사이즈 변경이 아닌 들어있는 값을 변경 할 수 있다.
    - 배열 출력
        .mkString(",")이용
    - Array[Int]
        val array1 = Array(1, 2, 3)
    - Array[Any]
        val array2 = Array("a", 2, true)
    - 배열값 읽고 쓰기
        array1(0) = 4
        printArray(array1)

    - 배열 + 배열 
        ~ ++ 연산자 이용
    - 값 + 배열
        ~ 값 +: 배열 
    - 배열 + 값
        ~ 배열 :+ 값

    - index찾기
        array.indecOf("값")
    - 다른 값만 가져오기
        val diffArray = Array(1,2,3,4).diff(Array(2,3))
        printArray(diffArray) // Array(1, 4)
    - Find 메소드를 이용해서 findByName이라는 메소드 생성
        // Find는 조건에 맞는 값을 찾으면 검색을 중단
        // getOrElse는 일치하는 값이 없을 경우 넘겨줄 기본 값
        // getOrElse가 없을때 일치하는 값이 없으면 None
        def findByName(name:String) = personArray.find(_._1 == name).getOrElse(("화사",4))
        val findSolar = findByName("솔라")  // 값("솔라",1)을 찾아서 넘겨줌
        val findSun = findByName("태양")  // 값이 없으므로 getOrElse에 있는 값("화사",4)이 

* List
    - scala.collection.immutable.List 이므로 값을 변경할 수 없는 속성을 가지고 있다.
        -> 변경사항을 반영한 새로운 리스트를 만들어내는 방식으로 동작

        // List[Any](기본 리스트를 사용하므로 Immutable) 
        val list = List("a", 1, true)
        
        // 값을 읽어올 수는 있지만 값을 변경 할 수는 없음
        val firstItem = list(0)
    
    - 연산
        // 앞에 붙이기는 :: 또는 +: 연산자
        // 리스트 두개를 붙이기는 ++ 또는 :::연산자
        // 뒤에 붙이기는 :+연산자(immutable list에서 효율적인 방법이 아님)
        val concatenated = 0 :: list ++ list :+ 1000


    
